# Example DB4Sci configuration file
#
# To configure DB4Sci, copy this file and name it local_cnf.py
#
# Every variable needs to be defined, there are no default values. The BaseConfig 
# should be the only section that you need to define.  Dev and Test sections are 
# useful for code development but nessisary for production systems.  
#
# This module is imported not read. This file needs to follow Python syntax
# rules. 
#
import os
import sys



class BaseConfig():
    # container_host use output from uname -n
    container_host = '172.16.123.1'
    FQDN_host = 'mydb.yourOrganization.org'
    # IP address of host that is running Docker
    container_ip = '172.16.123.1'
    admindb_name = 'mydb_admin'
    mydb_admin_port = '32009'

    # ISID of admin users, Admin uses can view/edit meta data
    admins = ['admin1', 'admin2', 'admin3']
    backup_admin_mail = ['backupadmin@yourOrganization.org']

    # eMail stuff
    MAIL_FROM = "HPC_staff@yourOrganization.org"
    MAIL_TO = ["admins@yourOrganization.org"]
    MAIL_SERVER = "smtp.yourOrganization.org"

    # Time Zone
    TZ = 'America/Los_Angeles'

    # Local Active Directory servers and Domain
    # DCs = ['dc10.yourDomain.org', 'dc20.yourDomain.org']
    DCs = ['demo']
    AD_domain = '@yourDomain.org'

    # Data Volumes for Databases
    # Configures the UI for selecting a volume which is used to host database
    # Storage. Initally this was a single volume. But uses came up for encrypted
    # volumes and sperate volume which can be used by system admin staff.
    #
    # <data_volumes> is a list of lists. Minimual configuration is a single
    # volume "Standard". "Standard" can be used for all databases by everybody.
    #  
    # col[0] = 'Lable' displayed in UI
    # col[1] = Volume path, mount at /mydb
    # col[l] = List of databases that can use the volume. ALL can be used. 
    #          Database type names are keys from <info>  
    #          ['Postgres', 'MongoDB', 'MariaDB', 'Neo4j']
    # col[3] = List of uses authorized to use the volume.  
    data_volumes = [['Standard',  '/mydb/dbs_data', ['ALL'], ['ALL']],
                    ['Admin',     '/mydb/admin_vol', ['Postgres'], ['admin', 'dbUser']],
                    ['Encrypted', '/mydb/encrypted/', ['Postgres'], ['hippaAdmin']],
                    ['Example',   '/dev/null', ['ALL'], ['nobody']],
                    ]
    backup_vol = '/mydb/db_backups'

    #
    # SECRETS
    #
    # For every type of database and for every database created by users
    # a privelged admin account is created. The account is used to
    # perform backups. Account names can be particular to the database
    # containter, don't change 'admin', just the admin_pass.
    # 
    accounts = {'Postgres': {'admin': 'pgdba',
                             'admin_pass': 'pgSecret'},
                'MongoDB': {'admin': 'dbaas', 'admin_pass': 'mongoSecret'},
                'MariaDB': {'admin': 'root', 'admin_pass': 'mariaSecret'},
                'Neo4j':   {'admin': 'neo4j', 'admin_pass': 'neoSecret'},
                # DB4Sci uses a database to maintain history and state of the application
                # set a username/password for the application database admin account.
                'admindb': {'admin': 'db4sci',
                            'admin_pass': 'admSecret',
                            'contact': 'admin@yourDomain.org',
                            'owner': 'Your Name'},
                # Define a user information used by test scripts
                'test_user': {'admin': 'tester',
                              'admin_pass': 'testSecret',
                              'contact': 'dev_gal@yourDomain.org',
                              'owner': 'Your Name'}
                }

    # AWS bucket for backups
    bucket = "s3://yourOrg-DB4Sci-backups/prod"


class ProdConfig(BaseConfig):
    def __init__(self, env):
        BaseConfig()
        self.env = env

    admindb_user = BaseConfig.accounts['admindb']['admin']
    admindb_password = BaseConfig.accounts['admindb']['admin_pass']
    port = BaseConfig.mydb_admin_port
    container_host = BaseConfig.container_host
    admindb_name = BaseConfig.admindb_name

    SQLALCHEMY_DATABASE_URI = "postgresql://" + admindb_user + ":"
    SQLALCHEMY_DATABASE_URI += admindb_password + "@"
    SQLALCHEMY_DATABASE_URI += container_host + ":" + port + "/"
    SQLALCHEMY_DATABASE_URI += admindb_name


class DevConfig(BaseConfig):
    def __init__(self, env):
        self.env = env

    admindb_user = BaseConfig.accounts['admindb']['admin']
    admindb_password = BaseConfig.accounts['admindb']['admin_pass']
    admindb_name = BaseConfig.admindb_name
    port = BaseConfig.mydb_admin_port
    container_host = 'db4sci-dev'
    FQDN_host = 'db4sci-dev.yourOrg.org'
    container_ip = '192.168.1.1'

    SQLALCHEMY_DATABASE_URI = "postgresql://" + admindb_user + ":"
    SQLALCHEMY_DATABASE_URI += admindb_password + "@"
    SQLALCHEMY_DATABASE_URI += container_host + ":" + port + "/"
    SQLALCHEMY_DATABASE_URI += admindb_name

    # Mail stuff
    MAIL_FROM = "valid_user@yourDomain.org"
    MAIL_TO = ["developer@yourDomain.org"]
    MAIL_SERVER = "smtp.yourDomain.org"
    # AWS stuff
    bucket = "s3://yourOrg-DB4Sci-backups/prod"


class TestConfig(DevConfig):
    def __init__(self, env):
        self.env = env
        self.info['Neo4j']['volumes'][3] = [
                '', '/mydb/repos/dbaas/dev/neo4j/ssl', '/ssl']

    dbaas_path = '/mydb/repos/dbaas/'


base_port = 32010

# images: List of Docker Images
# first column is 'Display Name'
# second column is 'image name'
# firt row of image is default
info = {'Postgres': {'pub_ports': [5432],
                     'backupdir': '/var/lib/postgresql/backup',
                     'volumes': [
                            ['DBVOL', '/', '/var/lib/postgresql/data'],
                            ['BAKVOL', '/', '/var/lib/postgresql/backup'],
                         ],
                     'command': 'postgres',
                     'dbengine': 'Postgres',
                     'images': [
                             ['Postgres 9.6.8', 'postgres:9.6.8'],
                             ['Postgres 10.3', 'postgres:10.3'],
                          ]},
        'MongoDB': {'pub_ports': [27017],
                    'backupdir': '/var/backup',
                    'volumes': [
                        ['DBVOL', '/db', '/data/db'],
                        ['DBVOL', '/configdb', '/data/configdb'],
                        ['BAKVOL', '/', '/var/backup'],
                    ],
                    'command': 'mongod',
                    'dbengine': 'MongoDB',
                    'images': [
                         ['MongoDB 3.4', 'mongo:3.4.1'],
                    ]},
        'MariaDB': {'pub_ports': [3306],
                    'backupdir': '/var/backup',
                    'volumes': [
                            ['DBVOL', '/', '/var/lib/mysql'],
                            ['BAKVOL', '/', '/var/backup'],
                    ],
                    'command': 'mysqld',
                    'dbengine': 'MariaDB',
                    'images': [
                             ['MariaDB 10.1', 'mariadb:10.1.21'],
                        ]},
        'Neo4j': {'pub_ports': [7473, 7687],  #7473:HTTPS  7687:Bolt
                  'backupdir': '/backup',
                  'volumes': [
                            ['DBVOL', '/data', '/data'],
                            ['DBVOL', '/logs', '/logs'],
                            ['BAKVOL', '/', '/backup'],
                        ],
                  'command': 'neo4j',
                  'dbengine': 'Neo4j',
                  'images': [
                             ['Neo4j 3.2.1', 'neo4j:3.2.1'],
                        ],
                  # <archive> a list of files to ADD to the container
                  # format: list of tuples (source_file, dest_file)
                  'archive': [('/ssl/yourOrganization.pem.crt', '/var/lib/neo4j/certificates/neo4j.cert'),
                                  ('/ssl/yourOrganization.org.key', '/var/lib/neo4j/certificates/neo4j.key'),
                                  ]
                  },
        }
dbtypes = info.keys()
env = os.environ.get('DBAAS_ENV')
if env == 'dev':
    var = DevConfig(env)
elif env == 'prod':
    var = ProdConfig(env)
elif env == 'test':
    var = TestConfig(env)
else:
    print('Error: The environment varaible DBAAS_ENV must be set to one of'),
    print("these values: ['prod', 'dev', 'test']")
    sys.exit(1)
